# Volatile

```java
public class Example {
  volatile boolean flag = true;
}
```

## Memory visibility

When use `volatile` keyword to declare variable, firstly you will get visibility of the variable cross different thread.

### Write & Read operation

The value will always write into main memory when write a volatile variable.

When read volatile variable also will always read from main memory.

<!-- generated by mermaid compile action - START -->
![~mermaid diagram 1~](/output/java_volatile-md-1.png)
<details>
  <summary>Mermaid markup</summary>

```mermaid
graph TD;
  A(Thread A write volatile var) -->|Write to| B[Main Memory];
  B -->|Read by| C(Thread B read volatile var)
```

</details>
<!-- generated by mermaid compile action - END -->

## Reorder

Like mentioned in the [[happens-before]] rule, JVM like other computer process will reoder the command.

But for volatile it's a special case, the volatile will prevent reorder for it's own read and write. Which can make sure the read will happen after write.

And in some cases, it will prevent reorder with normal variables too:

1. When first operation is `volatile` read, it won't reorder with following operation.
2. When second operation is `volatile` write, it won't reorder with previous operation.
3. When first operation is `volatile` wirte, second operation is `volatile` read, won't get reordered.

### How JVM do this

JVM use [[JMM]] memory block insersion to implement this. There are 4 types of blocks:

- LoadLoad
- StoreStore
- LoadStore
- StoreLoad (most expensive one)

## Usage

First of all, base on the memory visibility, volatile can use as a semi `lock`, which can make sure the changes communicate throw threads. But `volatile` only make sure the variable it self is `atomic`, while `lock` can make sure the whole block is `atomic`.

Volatile can prevent reorder which can work with `lock` to do the double lock check. For example, in singleton partern:

```java
public class Singleton {
  private static Singleton instance;
  public static Singleton getInstace() {
    if (instance == null) {
      synchronized (Singleton.class) {
        if (instance == null) {
          instance = new Singleton();
        }
      }
    }
    return instance;
  }
}
```

The above code can have issue when: Thread A allocated memory to `instance` but not done initializing, while Thread B is reading `instance`.

If use `volatile` to declare `instance` then it will prevent this type of reorder, which can prevent the issue.

```java
volatile private static Singleton instance;
```

[//begin]: # "Autogenerated link references for markdown compatibility"
[happens-before]: happens-before "Happens before rule"
[JMM]: JMM "Java memory model"
[//end]: # "Autogenerated link references"
